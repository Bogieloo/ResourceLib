package gq.arcstudio.resourceLib.ResourcePack;

import com.google.gson.*;
import gq.arcstudio.resourceLib.ResourceEntry;
import org.bukkit.Bukkit;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.zip.*;

public class ResourcePackBuilder {

    public static byte[] buildZip(List<ResourceEntry> entries) throws IOException {
        Map<String, MergedEntry> mergedEntries = new HashMap<>();

        for (ResourceEntry entry : entries) {
            MergedEntry existing = mergedEntries.get(entry.virtualPath);
            if (existing != null && isJsonFile(entry.virtualPath)) {
                JsonObject newJson = parseJson(entry.file);
                existing.mergeJson(newJson, entry.force);
            } else {
                mergedEntries.put(entry.virtualPath, new MergedEntry(entry));
            }
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (ZipOutputStream zip = new ZipOutputStream(baos)) {
            ZipEntry meta = new ZipEntry("pack.mcmeta");
            zip.putNextEntry(meta);
            zip.write(getDefaultMeta().getBytes(StandardCharsets.UTF_8));
            zip.closeEntry();

            for (var e : mergedEntries.entrySet()) {
                ZipEntry zipEntry = new ZipEntry(e.getKey());
                zip.putNextEntry(zipEntry);
                zip.write(e.getValue().getBytes());
                zip.closeEntry();
            }
        }

        return baos.toByteArray();
    }

    private static int getPackFormat() {
        String version = Bukkit.getServer().getVersion();
        if (version.contains("1.21.5")) return 55;
        if (version.contains("1.21")) return 34;
        if (version.contains("1.20.5") || version.contains("1.20.6")) return 32;
        if (version.contains("1.20.3") || version.contains("1.20.4")) return 22;
        if (version.contains("1.20.2")) return 18;
        if (version.contains("1.20.0") || version.contains("1.20.1")) return 15;
        if (version.contains("1.19.4")) return 13;
        if (version.contains("1.19.3")) return 12;
        if (version.contains("1.19.0") || version.contains("1.19.1") || version.contains("1.19.2")) return 9;
        if (version.contains("1.18")) return 8;
        if (version.contains("1.17")) return 7;

        Bukkit.getLogger().warning("[ResourceLib] Unknown server version " + version + ". Using default pack format 34. This may not work as intended.");
        return 34;
    }

    private static String getDefaultMeta() {
        int format = getPackFormat();
        Bukkit.getLogger().info("[ResourceLib] Using pack format " + format);
        return """
    {
      "pack": {
        "pack_format": %d,
        "description": "Generated by ResourceLib"
      }
    }
    """.formatted(format);
    }


    private static boolean isJsonFile(String path) {
        return path.toLowerCase().endsWith(".json");
    }

    private static JsonObject parseJson(File file) throws IOException {
        try (Reader r = new FileReader(file)) {
            return JsonParser.parseReader(r).getAsJsonObject();
        }
    }

    private static class MergedEntry {
        private byte[] raw;
        private JsonObject json;

        public MergedEntry(ResourceEntry entry) throws IOException {
            if (isJsonFile(entry.virtualPath)) {
                this.json = parseJson(entry.file);
            } else {
                this.raw = Files.readAllBytes(entry.file.toPath());
            }
        }

        public void mergeJson(JsonObject newJson, boolean forcePlugin) {
            if (json == null) json = newJson;
            else mergeRecursive(json, newJson, forcePlugin);
        }

        public byte[] getBytes() {
            if (json != null) return json.toString().getBytes(StandardCharsets.UTF_8);
            return raw;
        }

        private void mergeRecursive(JsonObject base, JsonObject addition, boolean force) {
            for (var e : addition.entrySet()) {
                if (base.has(e.getKey()) && base.get(e.getKey()).isJsonObject() && e.getValue().isJsonObject()) {
                    mergeRecursive(base.getAsJsonObject(e.getKey()), e.getValue().getAsJsonObject(), force);
                } else if (!base.has(e.getKey()) || force) {
                    base.add(e.getKey(), e.getValue());
                }
            }
        }
    }
}